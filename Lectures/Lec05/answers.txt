PLC:

5.1:

chap5.fsx file Line 2-8

Merge.java file


5.7:

in folder Lecture/Lec04/TypedFun

Line 40: Added TypL
Line 54: Added ListExpr (tyexpr list * typ)
Line 144: Added expression to check if list typing is correct

Test examples: 
open TypedFun;;
typ (ListExpr ([CstB false; CstI 3; CstB true], TypI)) [];; -> returns failwith "Wrong typing"
typ (ListExpr ([CstI 2; CstI 3; CstI 4], TypI)) [];; -> returns val it : typ = TypL TypI

6.1:

in folder Lecture/Lec05/ParseAndRunHigher

Line 63-90: Added ex10,ex11,ex12,ex13 and a small explanation for ex12 & ex13

6.2: 

in folders 
Lecture/Lec05/FunPar.fsy:

Added expression for functions

Added token "PIL" to represent a right arrow "->"

Added operator precedence for "PIL"

Lecture/Lec05/FunLex.fsl:

Added keyword "fun" to represen a function

Added token "PIL" to represent a right arrow "->" 

Lecture/Lec05/HigherFun.fs:

Line 33: Added Clos to represent the closure of anonymous functions

Line 69-73: Added a case for Clos to the eval functional

Line 74: Added a case for Fun to evaluate functions


6.3:
in folder Lectures/Lec05/Fun/ParseAndRunHigher.fs

Added the examples from the book as ex14 and ex15.
To test the examples please type it in the terminal like run(Parse.fromString("string"));; instead of run ex14

FunLex.fsl: Line 33 -> added keyword fun

FunPar.fsy: Line 43 -> added parsing of fun

6.4:

For the rule trees look at ex6.4.1.PNG and ex6.4.2.png in Lectures/Lec06/

Regarding polymorphism, it is because in 6.4.1 it can take any x, but in 6.4.2 it is required to be of type int because of the comparison



